#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <dirent.h>
#include <math.h>
#include <time.h>
#include <stdarg.h>
#include <SDL2/SDL.h>
#include <SDL2/SDL_mixer.h>

#define JSMN_IMPLEMENTATION
#include "jsmn.h"

// --- Configurações de Jogo ---
#pragma region "Configurações"
#define SCREEN_WIDTH 640
#define SCREEN_HEIGHT 480
#define FPS 60
#define NOTE_SIZE 40
#define TRIGGER_THRESHOLD 30000
#define TIME_WINDOW_SICK 45
#define TIME_WINDOW_GOOD 90
#define TIME_WINDOW_BAD  135
#define TIME_WINDOW_MISS 165
#define SCORE_SICK 350
#define SCORE_GOOD 200
#define SCORE_BAD  100
#define SCORE_MISS -10
#define MAX_VISIBLE_ITEMS 7
#pragma endregion

// --- Estruturas e Enums ---
#pragma region "Estruturas"
typedef enum { STATE_SONG_SELECT, STATE_DIFFICULTY_SELECT, STATE_OPTIONS, STATE_KEYBINDS, STATE_PLAYING, STATE_RESULTS } GameScreen;
typedef enum { SCROLL_UP, SCROLL_DOWN } ScrollDirection;
typedef enum { LOG_LEVEL_INFO, LOG_LEVEL_WARN, LOG_LEVEL_ERROR } LogLevel;
typedef struct { char* name; char* prefix; } SongEntry;
typedef struct { ScrollDirection scrollDir; bool isMiddleScroll; bool ghostTapping; double noteSpeed; SDL_Keycode keybinds_main[4]; SDL_Keycode keybinds_alt[4]; } GameOptions;
typedef struct { int score; int combo; int sicks; int goods; int bads; int shits; int misses; int highest_combo; int player_note_count; char rating[16]; Uint32 ratingTime; } GameState;
typedef struct { double timestamp; int type; double sustainLength; bool isPlayer1; bool wasHit; bool canBeHit; } ChartNote;
typedef struct NoteNode { ChartNote data; SDL_Rect rect; SDL_Rect tail_rect; struct NoteNode* next; } NoteNode;
#pragma endregion

// --- Sistema de Logging ---
#pragma region "Logging"
FILE* log_file = NULL;
void log_message(LogLevel level, const char* format, ...) { if (!log_file) return; time_t now = time(0); char time_buf[24]; strftime(time_buf, sizeof(time_buf), "%Y-%m-%d %H:%M:%S", localtime(&now)); const char* level_str[] = { "INFO", "WARN", "ERROR" }; fprintf(log_file, "[%s] [%s] ", time_buf, level_str[level]); va_list args; va_start(args, format); vfprintf(log_file, format, args); va_end(args); fprintf(log_file, "\n"); fflush(log_file); }
void init_logging() { log_file = fopen("log.txt", "w"); if (!log_file) { printf("ERRO CRÍTICO: Não foi possível criar o arquivo log.txt!\n"); } log_message(LOG_LEVEL_INFO, "Sistema de logging inicializado."); }
void shutdown_logging() { if (log_file) { log_message(LOG_LEVEL_INFO, "Sistema de logging finalizado."); fclose(log_file); } }
#pragma endregion

// --- Globais e Constantes ---
#pragma region "Globais e Constantes"
SDL_GameController *controller = NULL;
SDL_Texture* font_texture = NULL;
const SDL_Color COLOR_WHITE = {255, 255, 255, 255}, COLOR_SELECTED = {255, 255, 0, 255};
const SDL_Color PLAYER_COLORS[] = { {208, 70, 242, 255}, {0, 255, 255, 255}, {18, 250, 5, 255}, {249, 57, 63, 255} };
const int P1_POS_X_CLASSIC[] = {SCREEN_WIDTH - 60 - NOTE_SIZE*4, SCREEN_WIDTH - 60 - NOTE_SIZE*3, SCREEN_WIDTH - 60 - NOTE_SIZE*2, SCREEN_WIDTH - 60 - NOTE_SIZE};
const int P2_POS_X_CLASSIC[] = {60, 60 + NOTE_SIZE, 60 + NOTE_SIZE*2, 60 + NOTE_SIZE*3};
const int LANE_START_X_MIDDLE = (SCREEN_WIDTH - (12 * NOTE_SIZE)) / 2;
const int P1_POS_X_MIDDLE[] = {LANE_START_X_MIDDLE + NOTE_SIZE*4, LANE_START_X_MIDDLE + NOTE_SIZE*5, LANE_START_X_MIDDLE + NOTE_SIZE*6, LANE_START_X_MIDDLE + NOTE_SIZE*7};
const int P2_POS_X_MIDDLE[] = {LANE_START_X_MIDDLE, LANE_START_X_MIDDLE + NOTE_SIZE, LANE_START_X_MIDDLE + NOTE_SIZE*10, LANE_START_X_MIDDLE + NOTE_SIZE*11};
#pragma endregion

// --- Fonte de Bitmap Otimizada ---
#pragma region "Bitmap Font"
#define FONT_WIDTH 32
#define FONT_HEIGHT 32

// Mapeia o índice do array g_font_data para o caractere correspondente.
static const char* FONT_MAP = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";

// Subconjunto otimizado da fonte, contendo apenas os 95 caracteres de ASCII 32 a 126.
static const uint32_t g_font_data[95][FONT_HEIGHT] = {
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C000000,0x3E1FFF80,0x3E7FFF80,0x3E7FFF80,0x1C007F80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0xFF80,0xFF80,0xFF80,0x00,0x00,0x00,0xFF80,0xFF80,0xFF80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x600000,0x600000,0x60C000,0x3C60C000,0x3FE0C000,0xFFCC000,0xFFE000,0x6FFC00,0x60FF80,0x3860CF80,0x3FE0C080,0x1FF8C000,0x1FFC000,0x7FF800,0x61FF80,0x60FF80,0x60C180,0xC000,0xC000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x1C01F000,0x1C03F800,0x1807FC00,0x380E1E00,0x380E0E00,0x300C0E00,0xFFFFFFC0,0xFFFFFFC0,0x381C0E00,0x38180E00,0x38380E00,0x1FF80C00,0xFF01C00,0x7E00000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x607C00,0x20FE00,0x31C700,0x318300,0x198300,0x198300,0x9C700,0xCFE00,0xFCC7C00,0x1FE60000,0x18660000,0x38720000,0x30330000,0x38730000,0x38718000,0x1CE18000,0xFC08000,0x7008000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x3F00000,0x7FC0000,0xFFE0000,0x1E077E00,0x1C03FF00,0x3803FF00,0x38078380,0x300F0380,0x301E0180,0x38780180,0x38F00380,0x19E00380,0x1FC00300,0xF000000,0x3F800000,0x3FFC0000,0x30FC0000,0x201C0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF80,0xFF80,0xFF80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x3FFC000,0x1FFFF800,0x7FFFFE00,0xFC003F80,0xC00007C0,0xC0,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xC00003C0,0xF0001F80,0xFFC3FE00,0x3FFFF800,0x7FFE000,0x3C0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x6000,0x6000,0x406000,0x70C000,0x38C000,0x1FC000,0xFE000,0x3FF00,0x7FE00,0x1FC000,0x3CC000,0x70C000,0x60E000,0x6000,0x6000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x180000,0x180000,0x180000,0x180000,0x180000,0x180000,0x180000,0xFFFF800,0xFFFF800,0xFFFF800,0x180000,0x180000,0x180000,0x180000,0x180000,0x180000,0x180000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE000000,0x1F000000,0x9F000000,0xFF000000,0xFE000000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x300000,0x300000,0x300000,0x300000,0x300000,0x300000,0x300000,0x300000,0x300000,0x300000,0x300000,0x300000,0x300000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C000000,0x3E000000,0x3E000000,0x3E000000,0x1C000000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0xE0000000,0xF8000000,0x7E000000,0x1F800000,0x7E00000,0x1F80000,0x7F0000,0x1FC000,0x7F000,0xFC00,0x3F00,0xF80,0x380,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x7FC000,0x3FFF800,0xFFFFE00,0x1FC07F00,0x1C000700,0x38000380,0x381FC380,0x307FF180,0x383FE380,0x38000380,0x1C000700,0x1F001F00,0xFFFFE00,0x7FFFC00,0xFFE000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x38000700,0x38000700,0x38000700,0x38000380,0x38000380,0x3FFFFF80,0x3FFFFF80,0x3FFFFF80,0x38000000,0x38000000,0x38000000,0x38000000,0x38000000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x30000000,0x3C000700,0x3E000700,0x3F000380,0x37800380,0x33C00380,0x31E00180,0x30F00180,0x30780380,0x303C0380,0x301F0700,0x3007FF00,0x3003FE00,0x3001FC00,0x30000000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x1C000000,0x1C000300,0x38000300,0x38000380,0x38030380,0x30030380,0x30030180,0x30030180,0x38070380,0x38078380,0x1C0F8700,0x1E1DFF00,0xFFCFE00,0xFF87C00,0x3E00000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x1F00000,0x1F80000,0x1DE0000,0x1CF0000,0x1C3C000,0x1C0F000,0x1C07800,0x1C01E00,0x1C00F00,0x3FFFFF80,0x3FFFFF80,0x3FFFFF80,0x3FFFFF80,0x1C00000,0x1C00000,0xC00000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x1C000000,0x1801FF80,0x3801FF80,0x3801FF80,0x3801C180,0x3000C180,0x3000C180,0x3801C180,0x3801C180,0x3801C180,0x1C038180,0x1FBF8180,0xFFF0180,0x7FE0000,0xF00000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x7FC000,0x3FFF800,0xFFFFC00,0x1FFF3E00,0x1C038F00,0x38018700,0x3801C380,0x3000C380,0x3000C180,0x3801C180,0x3801C380,0x1E078380,0x1FFF8300,0xFFF0000,0x3FC0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x180,0x180,0x180,0x20000180,0x38000180,0x3F000180,0x3FC00180,0x7F80180,0x1FE0180,0x3FC180,0xFF180,0x1FF80,0x3F80,0xF80,0x180,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x3E00000,0xFF87C00,0x1FFCFF00,0x1E1DFF00,0x3C0F8780,0x38070380,0x38070380,0x30030180,0x38070380,0x38070380,0x38078380,0x1E1DFF00,0x1FFCFF00,0xFF87E00,0x3F03800,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x1F800,0x7FE00,0x180FFF00,0x381E0F00,0x381C0380,0x30180380,0x30180380,0x38180180,0x38180380,0x1C1C0380,0x1E0C0700,0xF871F00,0x7FFFE00,0x3FFFC00,0x7FE000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x700E000,0xF81F000,0xF81F000,0xF81F000,0x700E000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C03C000,0x3E07E000,0x3E07E000,0xFE07E000,0xFC03C000,0x70000000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x180000,0x3C0000,0x3C0000,0x3E0000,0x7E0000,0x660000,0xE70000,0xE70000,0xC38000,0x1C38000,0x1818000,0x381C000,0x381C000,0x300E000,0x700E000,0x700E000,0xE007000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0xC18000,0xC18000,0xC18000,0xC18000,0xC18000,0xC18000,0xC18000,0xC18000,0xC18000,0xC18000,0xC18000,0xC18000,0xC18000,0xC18000,0xC18000,0xC18000,0xC18000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x6006000,0x6006000,0x700E000,0x700E000,0x381C000,0x381C000,0x1818000,0x1C38000,0x1C38000,0xC30000,0xE70000,0x660000,0x7E0000,0x7E0000,0x3C0000,0x3C0000,0x180000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x700,0x700,0x300,0x1C000380,0x3E3C0380,0x3E3E0180,0x3E3F0380,0x38380,0x1C780,0xFF00,0xFF00,0x3E00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x300000,0xFFF8000,0x3FFFE000,0x7C00F000,0xF0003C00,0xC0001C00,0x80200E00,0x83FE0600,0x7FF0700,0xF078700,0xE038300,0xC018300,0xC018700,0xC018700,0xE038E00,0x7071E00,0xFFFFC00,0xFFFF000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x38000000,0x3F000000,0x3FE00000,0xFFE0000,0xFFC000,0xFFF800,0xE1FF00,0xE03F80,0xE00780,0xE01F80,0xE0FF80,0xEFFC00,0xFFE000,0x7FE0000,0x3FF00000,0x3F800000,0x3C000000,0x20000000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x3FFFFF80,0x3FFFFF80,0x3FFFFF80,0x30060180,0x30060180,0x30060180,0x30060180,0x30070180,0x38070380,0x380F0380,0x1C0FC700,0x1F3DFF00,0xFF9FE00,0xFF07800,0x3C00000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x3F8000,0x1FFF000,0x7FFFC00,0xFFBFE00,0x1F001F00,0x1C000700,0x38000380,0x38000380,0x38000380,0x30000180,0x38000380,0x38000380,0x38000380,0x18000700,0x1C000700,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x3FFFFF80,0x3FFFFF80,0x3FFFFF80,0x38000380,0x30000180,0x30000180,0x38000380,0x38000380,0x38000380,0x1C000700,0x1E000F00,0xF803E00,0x7FFFC00,0x3FFF800,0xFFE000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x3FFFFF80,0x3FFFFF80,0x3FFFFF80,0x38070380,0x30060180,0x30060180,0x30060180,0x30060180,0x30060180,0x30060180,0x30060180,0x30060180,0x30060180,0x30000180,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x3FFFFF80,0x3FFFFF80,0x3FFFFF80,0x60180,0x60180,0x60180,0x60180,0x60180,0x60180,0x60180,0x60180,0x60180,0x180,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0xFFE000,0x3FFF800,0x7FFFC00,0xF803E00,0x1E000F00,0x1C000700,0x38000380,0x38000380,0x30000180,0x300C0180,0x380C0380,0x380C0380,0x1FFC0300,0x1FFC0700,0xFFC0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x3FFFFF80,0x3FFFFF80,0x3FFFFF80,0x70000,0x60000,0x60000,0x60000,0x60000,0x60000,0x60000,0x60000,0x60000,0x3FFFFF80,0x3FFFFF80,0x3FFFFF80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x30000180,0x30000180,0x30000180,0x30000180,0x30000180,0x3FFFFF80,0x3FFFFF80,0x3FFFFF80,0x38000380,0x30000180,0x30000180,0x30000180,0x30000180,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x1C000000,0x1C000000,0x38000000,0x38000000,0x38000180,0x30000180,0x30000180,0x38000180,0x38000180,0x1E000380,0x1FFFFF80,0xFFFFF80,0x3FFFF80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x3FFFFF80,0x3FFFFF80,0x3FFFFF80,0x1E0000,0xF0000,0x78000,0xFC000,0x1FE000,0x7CF000,0xF87800,0x3F03C00,0x7C01E00,0x1F800F00,0x3E000780,0x3C000380,0x30000080,0x20000000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x3FFFFF80,0x3FFFFF80,0x3FFFFF80,0x3FFFFF80,0x38000000,0x38000000,0x38000000,0x38000000,0x38000000,0x38000000,0x38000000,0x38000000,0x38000000,0x38000000,0x38000000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x3FFFFF80,0x3FFFFF80,0x3FFFFF80,0x780,0x1F80,0xFC00,0x7E000,0x3F0000,0x3C0000,0x3F0000,0xFE000,0x1FC00,0x3F80,0x780,0x3FFFFF80,0x3FFFFF80,0x3FFFFF80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x3FFFFF80,0x3FFFFF80,0x3FFFFF80,0x1F80,0x3F00,0x1FC00,0x7E000,0x1F8000,0xFE0000,0x3F00000,0x1FC00000,0x3E000000,0x3FFFFF80,0x3FFFFF80,0x3FFFFF80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0xFFE000,0x7FFFC00,0xFFFFE00,0x1F803F00,0x1C000700,0x38000380,0x38000380,0x30000180,0x38000380,0x38000380,0x1C000700,0x1F001F00,0xFFFFE00,0x7FFFC00,0x1FFF000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x3FFFFF80,0x3FFFFF80,0x3FFFFF80,0xC0180,0xC0180,0xC0180,0xC0180,0xC0380,0xC0380,0xE0380,0xF0700,0x7FF00,0x7FE00,0x1FC00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0xFFE000,0x7FFFC00,0xFFFFE00,0x1F803F00,0x1C000700,0x38000380,0x38000380,0x30000180,0x38000380,0x78000380,0xFC000700,0xDF001F00,0x8FFFFE00,0x7FFFC00,0x1FFF000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x3FFFFF80,0x3FFFFF80,0x3FFFFF80,0xE0380,0xC0180,0xC0180,0xC0180,0xC0180,0x1E0380,0x1E0380,0x7F0700,0x1F3FF00,0x7E3FE00,0x1FC1FC00,0x3F007000,0x3C000000,0x30000000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0xC007000,0x1C01FC00,0x1803FE00,0x3807CF00,0x38070300,0x38070380,0x30070380,0x300E0180,0x380E0180,0x380E0380,0x381E0380,0x1C3C0380,0x1FFC0700,0xFF80700,0x7E00000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x180,0x180,0x180,0x180,0x180,0x180,0x180,0x3FFFFF80,0x3FFFFF80,0x3FFFFF80,0x380,0x180,0x180,0x180,0x180,0x180,0x180,0x180,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x1FFFF80,0x7FFFF80,0xFFFFF80,0x1F000000,0x1C000000,0x38000000,0x38000000,0x30000000,0x38000000,0x38000000,0x38000000,0x1E000000,0x1FFFFF80,0xFFFFF80,0x3FFFF80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x180,0xF80,0xFF80,0x7FF00,0x7FF000,0x3FF0000,0x1FF00000,0x3F800000,0x3C000000,0x3F000000,0x3FF00000,0x7FE0000,0x7FE000,0xFFE00,0x1FF80,0x1F80,0x380,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x380,0x1FF80,0x7FFF80,0x3FFFF800,0x3FF80000,0x3F000000,0x3FF00000,0x3FF0000,0x1FE000,0x3E000,0xFE000,0xFFC000,0x1FF80000,0x3F000000,0x3FE00000,0x3FFFE000,0x1FFFF80,0x7FF80,0xF80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x30000000,0x38000180,0x3E000380,0x1F800F80,0x7C03F00,0x3F07C00,0xF9F000,0x3FC000,0x1F8000,0x1F8000,0x7FE000,0x1F0F800,0x3E07C00,0xF801F00,0x3F000F80,0x3C000380,0x30000180,0x20000000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x180,0x380,0xF80,0x3F00,0x7C00,0x1F000,0x7E000,0x3FFF8000,0x3FFE0000,0x3FFF0000,0x7C000,0x3F000,0xFC00,0x3F00,0xF80,0x780,0x180,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x38000180,0x3E000180,0x3F000180,0x3FC00180,0x31F00180,0x30F80180,0x303E0180,0x301F0180,0x3007C180,0x3003E180,0x3000F980,0x30007F80,0x30001F80,0x30000F80,0x30000380,0x30000000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFFFFFFF0,0xFFFFFFF0,0x80000070,0x30,0x30,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x180,0x780,0x1F80,0x7E00,0x3F800,0xFE000,0x3F8000,0xFC0000,0x3F00000,0xFC00000,0x3F000000,0xFC000000,0xF0000000,0x80000000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x30,0x80000070,0xFFFFFFF0,0xFFFFFFF0,0xFFFFFFF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x4000,0x6000,0x7800,0x3C00,0x1E00,0xF00,0x780,0x380,0x380,0x700,0xE00,0x3C00,0x7800,0x7000,0x4000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x10,0x70,0xF0,0x1E0,0x380,0x300,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x7C00000,0xFE0E000,0x1FF06000,0x3C786000,0x38387000,0x38187000,0x30183000,0x38183000,0x38187000,0x38187000,0x1C186000,0xF9DE000,0x3FFFC000,0x3FFF8000,0x3FFC0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x3FFFFFC0,0x3FFFFFC0,0x3FFFFFC0,0xE01C000,0x1C006000,0x38007000,0x38007000,0x30003000,0x38007000,0x38007000,0x1E01E000,0x1FFFE000,0xFFFC000,0x3FF0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x3FF0000,0x7FF8000,0xFFFC000,0x1E01E000,0x1C00E000,0x38007000,0x38007000,0x30003000,0x30003000,0x38007000,0x38007000,0x18006000,0x1C00E000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x1FE0000,0x7FF8000,0xFFFC000,0x1E01E000,0x3C00F000,0x38007000,0x38007000,0x30003000,0x38007000,0x18006000,0xC00C000,0xFFFFFC0,0x3FFFFFC0,0x3FFFFFC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x1FE0000,0x7FF8000,0xFFFC000,0x1E19E000,0x1C18E000,0x38187000,0x38187000,0x38183000,0x30183000,0x30187000,0x38187000,0x3818E000,0x181FE000,0x1C1FC000,0x1C1F0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x3000,0x3000,0x3000,0x3000,0x3FFFFE00,0x3FFFFF80,0x3FFFFF80,0x71C0,0x31C0,0x30C0,0x30C0,0x30C0,0x30C0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x780000,0x3FF0000,0xFFFC000,0x1F87E000,0x1C00E000,0x38007000,0x38007000,0x30003000,0x38007000,0x18006000,0x1C00E000,0xF03C000,0xFFFFF000,0xFFFFF000,0x7FFFF000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x3FFFFFC0,0x3FFFFFC0,0x3FFFFFC0,0x1C000,0x6000,0x6000,0x3000,0x3000,0x7000,0x7000,0x3E000,0x3FFFE000,0x3FFFC000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x3000,0x3000,0x3000,0x3000,0x7FFF3C0,0xFFFF3C0,0x1FFFF3C0,0x3C000000,0x38000000,0x30000000,0x30000000,0x30000000,0x30000000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x3000,0x3000,0x3000,0x3000,0x3000,0xFFFFF3C0,0xFFFFF3C0,0xFFFFF3C0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x3FFFFFC0,0x3FFFFFC0,0x780000,0x380000,0x1C0000,0x3E0000,0x7F0000,0x1F38000,0x3E1C000,0xF80E000,0x1F007000,0x3C003000,0x38001000,0x30000000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0xC0,0xC0,0xC0,0xC0,0x1FFFFC0,0xFFFFFC0,0x1FFFFFC0,0x3E000000,0x38000000,0x38000000,0x30000000,0x30000000,0x30000000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x3FFFF000,0x3FFFF000,0xE000,0x6000,0x3000,0x7000,0x3FFFF000,0x3FFFE000,0x3FFFC000,0x6000,0x7000,0x3000,0x7000,0x3FFFF000,0x3FFFE000,0x3FFF0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x3FFFF000,0x3FFFF000,0x3FFFF000,0x1C000,0x6000,0x6000,0x3000,0x3000,0x7000,0x7000,0x3E000,0x3FFFE000,0x3FFFC000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0xFC0000,0x7FF8000,0xFFFC000,0x1F03E000,0x1C00E000,0x38007000,0x38007000,0x30003000,0x38007000,0x38007000,0x3C00F000,0x1E01E000,0xFFFC000,0x7FF8000,0x1FE0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0xFFFFF000,0xFFFFF000,0xFFFFF000,0xE01C000,0x18006000,0x38007000,0x30007000,0x30003000,0x38007000,0x38007000,0x1E01E000,0x1FFFE000,0xFFFC000,0x3FF0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0xFC0000,0x7FF8000,0xFFFC000,0x1F03E000,0x3C00F000,0x38007000,0x38007000,0x30003000,0x38007000,0x18006000,0x1C00E000,0xF87C000,0xFFFFF000,0xFFFFF000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x3FFFF000,0x3FFFF000,0x3FFFC000,0x1C000,0xE000,0x6000,0x7000,0x3000,0x3000,0x7000,0x7000,0xE000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x1C030000,0x180FC000,0x381FE000,0x381CE000,0x38387000,0x30387000,0x30303000,0x38303000,0x38707000,0x1C707000,0x1FE07000,0xFE0E000,0x7C00000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x3000,0x3000,0x3000,0x3000,0x7000,0xFFFFF80,0x1FFFFF80,0x3FFFFF80,0x38003000,0x38003000,0x30003000,0x30003000,0x30003000,0x30003000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x3FFF000,0xFFFF000,0x1FFFF000,0x3C000000,0x38000000,0x38000000,0x38000000,0x38000000,0x18000000,0xC000000,0xF800000,0x3FFFF000,0x3FFFF000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x7000,0x3F000,0x1FF000,0x7F8000,0x3FC0000,0x1FE00000,0x3F000000,0x3C000000,0x3E000000,0x3FC00000,0x7F80000,0xFF0000,0x1FE000,0x3F000,0x7000,0x1000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x3000,0x7F000,0x7FF000,0x7FF8000,0x3FF00000,0x3E000000,0x3F000000,0xFE00000,0xFE0000,0x1E0000,0x7E0000,0x7F00000,0x3F800000,0x3C000000,0x3FE00000,0x1FFF0000,0xFFF000,0xFF000,0x7000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x30001000,0x38003000,0x3E00F000,0x1F01E000,0x783C000,0x3EF0000,0xFE0000,0x7C0000,0xFE0000,0x1EF0000,0x7C7C000,0xF03E000,0x3E00F000,0x38007000,0x30001000,0x20000000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x3000,0x1F000,0xFF000,0x3FC000,0x1FE0000,0xFF00000,0xFF800000,0xFE000000,0xFF000000,0x1FC00000,0x7F80000,0xFF0000,0x1FE000,0x7F000,0xF000,0x1000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x38000000,0x3C003000,0x3F003000,0x3F803000,0x33C03000,0x31F03000,0x30783000,0x303C3000,0x301E3000,0x300FB000,0x3003F000,0x3001F000,0x3000F000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0xC0000,0xC0000,0xC0000,0x1C0000,0x1E0000,0x7F8000,0xFFF7FFC0,0xFFF3FFE0,0xFF807FF0,0x80000070,0x80000070,0x30,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFFFFFFC0,0xFFFFFFC0,0xFFFFFFC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x30,0x30,0x80000070,0x80000070,0xC00000F0,0xFFE3FFE0,0xFFF7FFC0,0x1FFFFE00,0x3E0000,0x1E0000,0x1C0000,0x1C0000,0xC0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x1800000,0x1F00000,0x1FC0000,0x1C0000,0xC0000,0xC0000,0x1C0000,0x3C0000,0x780000,0xF00000,0x1C00000,0x1C00000,0x1800000,0x1C00000,0xF80000,0x7C0000,0x1C0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
};

void create_font_texture(SDL_Renderer* renderer) {
    const int num_chars = strlen(FONT_MAP);
    int atlas_width = FONT_WIDTH * num_chars;

    SDL_Surface* font_surface = SDL_CreateRGBSurfaceWithFormat(0, atlas_width, FONT_HEIGHT, 32, SDL_PIXELFORMAT_ARGB8888);
    if (!font_surface) {
        log_message(LOG_LEVEL_ERROR, "Falha ao criar a superfície da fonte: %s", SDL_GetError());
        return;
    }

    SDL_FillRect(font_surface, NULL, SDL_MapRGBA(font_surface->format, 0, 0, 0, 0));
    SDL_LockSurface(font_surface);

    Uint32* pixels = (Uint32*)font_surface->pixels;
    Uint32 white = SDL_MapRGB(font_surface->format, 255, 255, 255);

    for (int char_idx = 0; char_idx < num_chars; ++char_idx) {
        for (int x = 0; x < FONT_WIDTH; ++x) {
            uint32_t col_data = g_font_data[char_idx][x];
            for (int y = 0; y < FONT_HEIGHT; ++y) {
                // CORREÇÃO: A versão anterior lia os bits em ordem invertida (31-y).
                // A ordem correta é ler o bit 'y' para a linha 'y', assumindo que
                // o bit 0 é o pixel do topo da coluna.
                if ((col_data >> y) & 1) {
                    int dest_x = char_idx * FONT_WIDTH + x;
                    pixels[y * atlas_width + dest_x] = white;
                }
            }
        }
    }

    SDL_UnlockSurface(font_surface);
    font_texture = SDL_CreateTextureFromSurface(renderer, font_surface);
    if (!font_texture) {
        log_message(LOG_LEVEL_ERROR, "Falha ao criar a textura da fonte: %s", SDL_GetError());
    }
    SDL_SetTextureBlendMode(font_texture, SDL_BLENDMODE_BLEND);
    SDL_FreeSurface(font_surface);
}

void render_text_bitmap(SDL_Renderer* renderer, const char* text, int x, int y, SDL_Color color, bool center) {
    if (!font_texture || !text) return;

    SDL_SetTextureColorMod(font_texture, color.r, color.g, color.b);
    int len = strlen(text);
    
    // Aumenta o tamanho base de 16px em 1.4x (16 * 1.4 = 22.4, arredondado para 22)
    const int render_char_width = 22;
    const int render_char_height = 22;

    if (center) {
        x -= (len * render_char_width) / 2;
    }

    for (int i = 0; i < len; ++i) {
        const char* found = strchr(FONT_MAP, text[i]);
        if (found) {
            int char_index = found - FONT_MAP;
            SDL_Rect src_rect = { char_index * FONT_WIDTH, 0, FONT_WIDTH, FONT_HEIGHT };
            SDL_Rect dest_rect = { x + i * render_char_width, y, render_char_width, render_char_height };
            SDL_RenderCopy(renderer, font_texture, &src_rect, &dest_rect);
        }
    }
}
#pragma endregion


// --- Funções Auxiliares ---
#pragma region "Funções Auxiliares"
static int jsoneq(const char *json, jsmntok_t *tok, const char *s) { return (tok->type == JSMN_STRING && (int)strlen(s) == tok->end - tok->start && strncmp(json + tok->start, s, tok->end - tok->start) == 0); }
int compareNotes(const void* a, const void* b) { ChartNote* nA = (ChartNote*)a; ChartNote* nB = (ChartNote*)b; if (nA->timestamp < nB->timestamp) return -1; if (nA->timestamp > nB->timestamp) return 1; return 0; }
int skip_token(jsmntok_t *t, int i) { int n = i + 1; if (t[i].type == JSMN_OBJECT || t[i].type == JSMN_ARRAY) { for (int j = 0; j < t[i].size; j++) { if (t[i].type == JSMN_OBJECT) n = skip_token(t, n); n = skip_token(t, n); } } return n; }
ChartNote* load_chart(const char* path, int* note_count, double* noteSpeed) { FILE* f = fopen(path, "rb"); if (!f) { log_message(LOG_LEVEL_ERROR, "Não foi possível abrir o arquivo do chart: %s", path); return NULL; } fseek(f, 0, SEEK_END); long l = ftell(f); fseek(f, 0, SEEK_SET); char* js = malloc(l + 1); if (!js) { fclose(f); log_message(LOG_LEVEL_ERROR, "Falha ao alocar memória para o string JSON."); return NULL; } fread(js, 1, l, f); fclose(f); js[l] = '\0'; jsmn_parser p; jsmntok_t *t = NULL; ChartNote* nb = NULL; jsmn_init(&p); int r = jsmn_parse(&p, js, l, NULL, 0); if (r < 0) { log_message(LOG_LEVEL_ERROR, "Falha ao analisar JSON (passagem 1, código %d) em %s.", r, path); free(js); return NULL; } t = malloc(sizeof(jsmntok_t) * r); if (!t) { log_message(LOG_LEVEL_ERROR, "Falha ao alocar memória para tokens JSMN."); free(js); return NULL; } jsmn_init(&p); r = jsmn_parse(&p, js, l, t, r); if (r < 0) { log_message(LOG_LEVEL_ERROR, "Erro na segunda passagem do parser JSMN (código %d).", r); goto cleanup; } nb = malloc(sizeof(ChartNote) * 65536); if (!nb) { goto cleanup; } *note_count = 0; int n_arr_tok = -1; for (int i = 1; i < r; i++) { if (jsoneq(js, &t[i], "notes") && t[i+1].type == JSMN_ARRAY) { n_arr_tok = i + 1; break; } } if (n_arr_tok == -1) { log_message(LOG_LEVEL_WARN, "Array 'notes' não foi encontrado em %s.", path); goto cleanup; } for(int i=1; i<r; i++) { if(jsoneq(js, &t[i], "speed")) { char speed_str[16]; snprintf(speed_str, t[i+1].end-t[i+1].start+1, "%s", js+t[i+1].start); *noteSpeed = atof(speed_str); break; } } int tok_idx = n_arr_tok + 1; for (int i = 0; i < t[n_arr_tok].size; i++) { jsmntok_t *sec_obj = &t[tok_idx], *notes_tok = NULL; int inner_idx = tok_idx + 1; for (int j = 0; j < sec_obj->size; j++) { jsmntok_t *key = &t[inner_idx]; if (jsoneq(js, key, "sectionNotes")) { notes_tok = &t[inner_idx + 1]; } inner_idx = skip_token(t, inner_idx + 1); } if (notes_tok && notes_tok->type == JSMN_ARRAY) { int note_ptr = tok_idx + 1; while(&t[note_ptr] != notes_tok) note_ptr++; note_ptr++; for (int k = 0; k < notes_tok->size; k++) { jsmntok_t* note_arr = &t[note_ptr]; char ts_s[32], ty_s[16], sus_s[32] = "0"; snprintf(ts_s, t[note_ptr+1].end - t[note_ptr+1].start + 1, "%s", js + t[note_ptr+1].start); snprintf(ty_s, t[note_ptr+2].end - t[note_ptr+2].start + 1, "%s", js + t[note_ptr+2].start); if (note_arr->size > 2) { snprintf(sus_s, t[note_ptr+3].end - t[note_ptr+3].start + 1, "%s", js + t[note_ptr+3].start); } int nt = atoi(ty_s); nb[*note_count].timestamp = atof(ts_s); nb[*note_count].type = nt; nb[*note_count].sustainLength = atof(sus_s); nb[*note_count].isPlayer1 = (nt < 4); nb[*note_count].wasHit = false; nb[*note_count].canBeHit = (nt < 4); (*note_count)++; note_ptr = skip_token(t, note_ptr); } } tok_idx = skip_token(t, tok_idx); } qsort(nb, *note_count, sizeof(ChartNote), compareNotes); free(js); free(t); log_message(LOG_LEVEL_INFO, "Chart '%s' carregado com sucesso. %d notas encontradas.", path, *note_count); return nb; cleanup: free(js); if(t) free(t); if(nb) free(nb); log_message(LOG_LEVEL_ERROR, "Falha ao processar a estrutura do chart '%s'.", path); return NULL; }
bool file_exists(const char *filename) { FILE *file = fopen(filename, "r"); if (file) { fclose(file); return true; } return false; }
#pragma endregion

// --- Lógica do Jogo ---
#pragma region "Lógica do Jogo"
NoteNode* handle_note_hit(int lane, NoteNode* active_notes, GameState* state, Uint32 song_time, bool ghostTapping) {
    NoteNode* best_note = NULL; double min_diff = TIME_WINDOW_MISS + 1.0;
    for (NoteNode* curr = active_notes; curr != NULL; curr = curr->next) { if (curr->data.canBeHit && !curr->data.wasHit && (curr->data.type % 4 == lane)) { double diff = fabs(curr->data.timestamp - song_time); if (diff < min_diff) { min_diff = diff; best_note = curr; } } }
    if (best_note) { best_note->data.wasHit = true; if (min_diff <= TIME_WINDOW_SICK) { state->score += SCORE_SICK; state->combo++; state->sicks++; strcpy(state->rating, "SICK!"); } else if (min_diff <= TIME_WINDOW_GOOD) { state->score += SCORE_GOOD; state->combo++; state->goods++; strcpy(state->rating, "GOOD"); } else if (min_diff <= TIME_WINDOW_BAD) { state->score += SCORE_BAD; state->combo = 0; state->bads++; strcpy(state->rating, "BAD"); } else { state->score += SCORE_MISS; state->combo = 0; state->shits++; strcpy(state->rating, "SHIT"); } state->ratingTime = SDL_GetTicks(); if(state->combo > state->highest_combo) state->highest_combo = state->combo; return best_note; }
    else if (!ghostTapping) { state->combo = 0; state->misses++; }
    return NULL;
}
void draw_receptors(SDL_Renderer* renderer, const bool keys_down[], GameOptions* options) { int receptor_y = (options->scrollDir == SCROLL_DOWN) ? SCREEN_HEIGHT - 50 : 50; const int* p1_pos = options->isMiddleScroll ? P1_POS_X_MIDDLE : P1_POS_X_CLASSIC; const int* p2_pos = options->isMiddleScroll ? P2_POS_X_MIDDLE : P2_POS_X_CLASSIC; for (int i = 0; i < 4; i++) { SDL_Rect r_p1 = {p1_pos[i], receptor_y, NOTE_SIZE, NOTE_SIZE}; if (keys_down[i]) { SDL_SetRenderDrawColor(renderer, PLAYER_COLORS[i].r, PLAYER_COLORS[i].g, PLAYER_COLORS[i].b, 255); SDL_RenderFillRect(renderer, &r_p1); } else { SDL_SetRenderDrawColor(renderer, 100, 100, 100, 255); SDL_RenderFillRect(renderer, &r_p1); } SDL_Rect r_p2 = {p2_pos[i], receptor_y, NOTE_SIZE, NOTE_SIZE}; SDL_SetRenderDrawColor(renderer, PLAYER_COLORS[i].r, PLAYER_COLORS[i].g, PLAYER_COLORS[i].b, 100); SDL_RenderDrawRect(renderer, &r_p2); } }
GameState run_game(SDL_Renderer* renderer, GameOptions* options, const char* chart_path) {
    int total_notes = 0; options->noteSpeed = 1.0; ChartNote* all_notes = load_chart(chart_path, &total_notes, &options->noteSpeed);
    GameState state = {0}; strcpy(state.rating, ""); if (!all_notes) { return state; }
    for(int i=0; i < total_notes; i++) { if(all_notes[i].isPlayer1) state.player_note_count++; }
    char prefix[512] = ""; char song_folder[256] = {0}; char temp_path[1024]; strncpy(temp_path, chart_path, sizeof(temp_path) - 1);
    char* data_ptr = strstr(temp_path, "data/"); if (data_ptr) { size_t prefix_len = data_ptr - temp_path; if (prefix_len > 0) { strncpy(prefix, temp_path, prefix_len); prefix[prefix_len] = '\0'; } }
    char *ls = strrchr(temp_path, '/'); if (ls) *ls = '\0';
    ls = strrchr(temp_path, '/'); if (ls) strncpy(song_folder, ls + 1, sizeof(song_folder)-1);
    char audio_path[1024]; Mix_Music* music = NULL; Mix_Chunk* p_v = NULL; Mix_Chunk* o_v = NULL;
    snprintf(audio_path, sizeof(audio_path), "%ssongs/%s/Inst.ogg", prefix, song_folder); music = Mix_LoadMUS(audio_path);
    if (!music) { snprintf(audio_path, sizeof(audio_path), "%ssongs/%s/Voices.ogg", prefix, song_folder); music = Mix_LoadMUS(audio_path); }
    if(!music) log_message(LOG_LEVEL_ERROR, "Nenhuma faixa de áudio principal encontrada para '%s'.", song_folder);
    snprintf(audio_path, sizeof(audio_path), "%ssongs/%s/Voices-Player.ogg", prefix, song_folder); p_v = Mix_LoadWAV(audio_path);
    snprintf(audio_path, sizeof(audio_path), "%ssongs/%s/Voices-Opponent.ogg", prefix, song_folder); o_v = Mix_LoadWAV(audio_path);
    NoteNode* active_notes = NULL; bool keys_down[4] = {false}; int next_note = 0;
    NoteNode* player_holding_note[4] = {NULL, NULL, NULL, NULL};
    if (music) Mix_PlayMusic(music, 1); if (p_v) Mix_PlayChannel(1, p_v, 0); if (o_v) Mix_PlayChannel(2, o_v, 0);
    Uint32 start_time = SDL_GetTicks(); bool game_running = true;
    while (game_running) {
        Uint32 song_time = SDL_GetTicks() - start_time;
        SDL_Event e;
        while (SDL_PollEvent(&e) != 0) {
            if (e.type == SDL_QUIT || (e.type == SDL_KEYDOWN && e.key.keysym.sym == SDLK_ESCAPE)) { game_running = false; }
            int lane = -1;
            if (e.type == SDL_KEYDOWN || e.type == SDL_KEYUP) {
                bool is_down = (e.type == SDL_KEYDOWN);
                for(int i=0; i<4; i++) { if (e.key.keysym.sym == options->keybinds_main[i] || e.key.keysym.sym == options->keybinds_alt[i]) { lane = i; break; } }
                if(lane != -1) {
                    keys_down[lane] = is_down;
                    if(is_down) { NoteNode* hit_note = handle_note_hit(lane, active_notes, &state, song_time, options->ghostTapping); if(hit_note && hit_note->data.sustainLength > 0) player_holding_note[lane] = hit_note; }
                    else { player_holding_note[lane] = NULL; }
                }
            }
            if (e.type == SDL_CONTROLLERBUTTONDOWN || e.type == SDL_CONTROLLERBUTTONUP) {
                bool is_down = (e.type == SDL_CONTROLLERBUTTONDOWN);
                switch (e.cbutton.button) { case SDL_CONTROLLER_BUTTON_DPAD_LEFT: case SDL_CONTROLLER_BUTTON_LEFTSHOULDER: lane = 0; break; case SDL_CONTROLLER_BUTTON_DPAD_DOWN: lane = 1; break; case SDL_CONTROLLER_BUTTON_DPAD_UP: lane = 2; break; case SDL_CONTROLLER_BUTTON_DPAD_RIGHT: case SDL_CONTROLLER_BUTTON_RIGHTSHOULDER: lane = 3; break; }
                if(lane != -1) {
                    keys_down[lane] = is_down;
                    if(is_down) { NoteNode* hit_note = handle_note_hit(lane, active_notes, &state, song_time, options->ghostTapping); if(hit_note && hit_note->data.sustainLength > 0) player_holding_note[lane] = hit_note; }
                    else { player_holding_note[lane] = NULL; }
                }
            }
             if (e.type == SDL_CONTROLLERAXISMOTION) {
                if (e.caxis.axis == SDL_CONTROLLER_AXIS_TRIGGERLEFT) {
                    bool is_down = e.caxis.value > TRIGGER_THRESHOLD;
                    keys_down[1] = is_down;
                    if (is_down) { NoteNode* hit_note = handle_note_hit(1, active_notes, &state, song_time, options->ghostTapping); if(hit_note && hit_note->data.sustainLength > 0) player_holding_note[1] = hit_note; }
                    else { player_holding_note[1] = NULL; }
                }
                if (e.caxis.axis == SDL_CONTROLLER_AXIS_TRIGGERRIGHT) {
                    bool is_down = e.caxis.value > TRIGGER_THRESHOLD;
                    keys_down[2] = is_down;
                    if (is_down) { NoteNode* hit_note = handle_note_hit(2, active_notes, &state, song_time, options->ghostTapping); if(hit_note && hit_note->data.sustainLength > 0) player_holding_note[2] = hit_note; }
                    else { player_holding_note[2] = NULL; }
                }
            }
        }
        while (next_note < total_notes && all_notes[next_note].timestamp <= song_time + 2000) { NoteNode* n = malloc(sizeof(NoteNode)); n->data = all_notes[next_note++]; n->next = active_notes; active_notes = n; }
        for(int i=0; i<4; i++) { if(player_holding_note[i] != NULL) { double end_time = player_holding_note[i]->data.timestamp + player_holding_note[i]->data.sustainLength; if(!keys_down[i] && song_time < end_time) { state.combo = 0; state.misses++; player_holding_note[i] = NULL; } } }
        NoteNode** ptr = &active_notes;
        while (*ptr) { NoteNode* entry = *ptr; double time_diff = entry->data.timestamp - song_time; if (!entry->data.wasHit && entry->data.canBeHit && time_diff < -TIME_WINDOW_MISS) { entry->data.wasHit = true; state.combo = 0; state.misses++; strcpy(state.rating, "MISS"); state.ratingTime = SDL_GetTicks(); } if (time_diff < -1000) { *ptr = entry->next; free(entry); } else { ptr = &entry->next; } }
        SDL_SetRenderDrawColor(renderer, 20, 20, 20, 255); SDL_RenderClear(renderer);
        draw_receptors(renderer, keys_down, options);
        const int* p1_pos = options->isMiddleScroll ? P1_POS_X_MIDDLE : P1_POS_X_CLASSIC; const int* p2_pos = options->isMiddleScroll ? P2_POS_X_MIDDLE : P2_POS_X_CLASSIC;
        for (NoteNode* curr = active_notes; curr != NULL; curr = curr->next) { if (curr->data.wasHit) continue; int type_mod_4 = curr->data.type % 4; curr->rect.x = curr->data.isPlayer1 ? p1_pos[type_mod_4] : p2_pos[type_mod_4]; curr->rect.w = NOTE_SIZE; curr->rect.h = NOTE_SIZE; double time_diff = curr->data.timestamp - song_time; double note_pos = time_diff * options->noteSpeed * 0.25; int receptor_y = (options->scrollDir == SCROLL_DOWN) ? SCREEN_HEIGHT - 50 : 50; curr->rect.y = (options->scrollDir == SCROLL_DOWN) ? receptor_y - note_pos : receptor_y + note_pos; if (curr->data.sustainLength > 0) { double tail_len_px = curr->data.sustainLength * options->noteSpeed * 0.25; curr->tail_rect.x = curr->rect.x + (NOTE_SIZE / 4); curr->tail_rect.w = NOTE_SIZE / 2; if (options->scrollDir == SCROLL_DOWN) { curr->tail_rect.y = curr->rect.y + NOTE_SIZE / 2 - tail_len_px; curr->tail_rect.h = tail_len_px; } else { curr->tail_rect.y = curr->rect.y + NOTE_SIZE / 2; curr->tail_rect.h = tail_len_px; } SDL_SetRenderDrawColor(renderer, PLAYER_COLORS[type_mod_4].r, PLAYER_COLORS[type_mod_4].g, PLAYER_COLORS[type_mod_4].b, 150); SDL_RenderFillRect(renderer, &curr->tail_rect); } SDL_SetRenderDrawColor(renderer, PLAYER_COLORS[type_mod_4].r, PLAYER_COLORS[type_mod_4].g, PLAYER_COLORS[type_mod_4].b, 255); SDL_RenderFillRect(renderer, &curr->rect); }
        char hud_buffer[64]; sprintf(hud_buffer, "Score: %d", state.score); render_text_bitmap(renderer, hud_buffer, 10, 10, COLOR_WHITE, false); sprintf(hud_buffer, "Misses: %d", state.misses + state.shits); render_text_bitmap(renderer, hud_buffer, 10, 40, COLOR_WHITE, false);
        if (SDL_GetTicks() - state.ratingTime < 500) { render_text_bitmap(renderer, state.rating, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 + 100, COLOR_WHITE, true); }
        SDL_RenderPresent(renderer); SDL_Delay(1000 / FPS);
        bool end_condition = false; if (music) { if (Mix_PlayingMusic() == 0 && active_notes == NULL) end_condition = true; } else if (total_notes > 0) { if (song_time > all_notes[total_notes - 1].timestamp + 4000) end_condition = true; }
        if(end_condition) game_running = false;
    }
    while(active_notes) { NoteNode* temp = active_notes; active_notes = active_notes->next; free(temp); }
    free(all_notes); Mix_HaltMusic(); Mix_HaltChannel(-1); if(music) Mix_FreeMusic(music); if(p_v) Mix_FreeChunk(p_v); if(o_v) Mix_FreeChunk(o_v);
    return state;
}
#pragma endregion

// --- Função Principal com Máquina de Estados de Menu ---
int main(int argc, char* argv[]) {
    init_logging();
    SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_GAMECONTROLLER);
    Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 4, 2048);
    
    for (int i = 0; i < SDL_NumJoysticks(); ++i) { if (SDL_IsGameController(i)) { controller = SDL_GameControllerOpen(i); if (controller) { log_message(LOG_LEVEL_INFO, "Controle detectado: %s", SDL_GameControllerName(controller)); break; } } }
    SDL_Window* window = SDL_CreateWindow("FNF Chart Renderer", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, SCREEN_WIDTH, SCREEN_HEIGHT, 0);
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    
    create_font_texture(renderer);

    GameScreen currentScreen = STATE_SONG_SELECT;
    GameOptions options = {SCROLL_DOWN, false, true, 1.0, {SDLK_LEFT, SDLK_DOWN, SDLK_UP, SDLK_RIGHT}, {SDLK_d, SDLK_f, SDLK_j, SDLK_k}};
    GameState results;
    SongEntry songs[256]; int song_count = 0;
    char* difficulties[16]; int diff_count = 0;
    int sel_song_idx = 0; int sel_diff_idx = 0; int sel_option_idx = 0;
    int keybind_to_change = -1;
    
    struct dirent *entry;

    DIR* data_dir = opendir("data"); if(data_dir) { while ((entry = readdir(data_dir)) != NULL) { if (entry->d_type == DT_DIR && strcmp(entry->d_name, ".")!=0 && strcmp(entry->d_name, "..")!=0) { songs[song_count].name = strdup(entry->d_name); songs[song_count].prefix = strdup(""); song_count++; } } closedir(data_dir); }
    DIR* mods_dir = opendir("mods"); if(mods_dir) { struct dirent* mod_entry; while((mod_entry = readdir(mods_dir)) != NULL) { if(mod_entry->d_type == DT_DIR && strcmp(mod_entry->d_name, ".")!=0 && strcmp(mod_entry->d_name, "..")!=0) { char mod_data_path[512]; snprintf(mod_data_path, sizeof(mod_data_path), "mods/%s/data", mod_entry->d_name); DIR* mod_data_dir = opendir(mod_data_path); if(mod_data_dir) { struct dirent* song_entry; while((song_entry = readdir(mod_data_dir)) != NULL) { if(song_entry->d_type == DT_DIR && strcmp(song_entry->d_name, ".")!=0 && strcmp(song_entry->d_name, "..")!=0) { songs[song_count].name = strdup(song_entry->d_name); char prefix_buf[512]; snprintf(prefix_buf, sizeof(prefix_buf), "mods/%s/", mod_entry->d_name); songs[song_count].prefix = strdup(prefix_buf); song_count++; } } closedir(mod_data_dir); } } } closedir(mods_dir); }
    if(song_count == 0) log_message(LOG_LEVEL_WARN, "Nenhuma música encontrada em /data/ ou /mods/.");
    
    int sel_song_scroll_offset = 0;
    int sel_diff_scroll_offset = 0;
    
    bool running = true;
    while (running) {
        SDL_Event e;
        while (SDL_PollEvent(&e) != 0) {
            if (e.type == SDL_QUIT) { running = false; }
            if (keybind_to_change != -1) { if (e.type == SDL_KEYDOWN) { if (keybind_to_change < 4) options.keybinds_main[keybind_to_change] = e.key.keysym.sym; else options.keybinds_alt[keybind_to_change - 4] = e.key.keysym.sym; keybind_to_change = -1; } continue; }
            bool nav_up=0, nav_down=0, nav_left=0, nav_right=0, nav_accept=0, nav_back=0;
            if (e.type == SDL_KEYDOWN) { switch (e.key.keysym.sym) { case SDLK_UP: nav_up=1; break; case SDLK_DOWN: nav_down=1; break; case SDLK_LEFT: nav_left=1; break; case SDLK_RIGHT: nav_right=1; break; case SDLK_RETURN: case SDLK_SPACE: nav_accept=1; break; case SDLK_ESCAPE: nav_back=1; break; } }
            if (e.type == SDL_CONTROLLERBUTTONDOWN) { switch (e.cbutton.button) { case SDL_CONTROLLER_BUTTON_DPAD_UP: nav_up=1; break; case SDL_CONTROLLER_BUTTON_DPAD_DOWN: nav_down=1; break; case SDL_CONTROLLER_BUTTON_DPAD_LEFT: nav_left=1; break; case SDL_CONTROLLER_BUTTON_DPAD_RIGHT: nav_right=1; break; case SDL_CONTROLLER_BUTTON_A: case SDL_CONTROLLER_BUTTON_START: nav_accept=1; break; case SDL_CONTROLLER_BUTTON_B: case SDL_CONTROLLER_BUTTON_BACK: nav_back=1; break; } }
            
            if (currentScreen == STATE_SONG_SELECT && song_count > 0) {
                if (nav_up) sel_song_idx = (sel_song_idx - 1 + song_count) % song_count;
                if (nav_down) sel_song_idx = (sel_song_idx + 1) % song_count;
                if (sel_song_idx < sel_song_scroll_offset) sel_song_scroll_offset = sel_song_idx;
                if (sel_song_idx >= sel_song_scroll_offset + MAX_VISIBLE_ITEMS) sel_song_scroll_offset = sel_song_idx - MAX_VISIBLE_ITEMS + 1;

                if (nav_accept) { for(int i=0; i<diff_count; i++) free(difficulties[i]); diff_count=0; char path[512]; snprintf(path, sizeof(path), "%sdata/%s", songs[sel_song_idx].prefix, songs[sel_song_idx].name); DIR* dir = opendir(path); if(dir){ while ((entry = readdir(dir)) != NULL) { if (strstr(entry->d_name, ".json")) { difficulties[diff_count++] = strdup(entry->d_name); } } closedir(dir); } sel_diff_idx=0; sel_diff_scroll_offset=0; currentScreen = STATE_DIFFICULTY_SELECT; log_message(LOG_LEVEL_INFO, "Música selecionada: %s", songs[sel_song_idx].name); }
            } else if (currentScreen == STATE_DIFFICULTY_SELECT && diff_count > 0) {
                if (nav_up) sel_diff_idx = (sel_diff_idx - 1 + diff_count) % diff_count;
                if (nav_down) sel_diff_idx = (sel_diff_idx + 1) % diff_count;
                if (sel_diff_idx < sel_diff_scroll_offset) sel_diff_scroll_offset = sel_diff_idx;
                if (sel_diff_idx >= sel_diff_scroll_offset + MAX_VISIBLE_ITEMS) sel_diff_scroll_offset = sel_diff_idx - MAX_VISIBLE_ITEMS + 1;

                if (nav_accept) { sel_option_idx=0; currentScreen = STATE_OPTIONS; } if (nav_back) { currentScreen = STATE_SONG_SELECT; }
            } else if (currentScreen == STATE_OPTIONS) {
                const int opt_count = 5; if (nav_up) sel_option_idx = (sel_option_idx - 1 + opt_count) % opt_count; if (nav_down) sel_option_idx = (sel_option_idx + 1) % opt_count;
                if (nav_accept) { if (sel_option_idx == 3) { currentScreen = STATE_KEYBINDS; sel_option_idx=0; } else if (sel_option_idx == 4) { char path[512]; snprintf(path, sizeof(path), "%sdata/%s/%s", songs[sel_song_idx].prefix, songs[sel_song_idx].name, difficulties[sel_diff_idx]); results = run_game(renderer, &options, path); currentScreen = STATE_RESULTS; } }
                if (nav_left || nav_right) { if (sel_option_idx == 0) { options.scrollDir = (options.scrollDir == SCROLL_UP) ? SCROLL_DOWN : SCROLL_UP; } else if (sel_option_idx == 1) { options.isMiddleScroll = !options.isMiddleScroll; } else if (sel_option_idx == 2) { options.ghostTapping = !options.ghostTapping; } }
                if (nav_back) { currentScreen = STATE_DIFFICULTY_SELECT; }
            } else if (currentScreen == STATE_KEYBINDS) {
                const int key_count = 9; if (nav_up) sel_option_idx = (sel_option_idx - 1 + key_count) % key_count; if (nav_down) sel_option_idx = (sel_option_idx + 1) % key_count;
                if (nav_accept) { if(sel_option_idx < 8) keybind_to_change = sel_option_idx; else currentScreen = STATE_OPTIONS; } if (nav_back) { currentScreen = STATE_OPTIONS; }
            } else if (currentScreen == STATE_RESULTS) { if(nav_accept || nav_back) { currentScreen = STATE_SONG_SELECT; } }
        }
        SDL_SetRenderDrawColor(renderer, 20, 20, 20, 255); SDL_RenderClear(renderer);
        if (currentScreen == STATE_SONG_SELECT) {
            render_text_bitmap(renderer, "Selecione a Musica", SCREEN_WIDTH/2, 30, COLOR_WHITE, true);
            if(song_count > 0) {
                int start_y = 100;
                for(int i = sel_song_scroll_offset; i < sel_song_scroll_offset + MAX_VISIBLE_ITEMS && i < song_count; i++) {
                    render_text_bitmap(renderer, songs[i].name, SCREEN_WIDTH/2, start_y, (i == sel_song_idx ? COLOR_SELECTED : COLOR_WHITE), true);
                    start_y += 40;
                }
            } else render_text_bitmap(renderer, "Nenhuma musica encontrada", SCREEN_WIDTH/2, 100, COLOR_WHITE, true);
        } else if (currentScreen == STATE_DIFFICULTY_SELECT) {
             render_text_bitmap(renderer, songs[sel_song_idx].name, SCREEN_WIDTH/2, 30, COLOR_WHITE, true);
            int start_y = 100;
            for(int i = sel_diff_scroll_offset; i < sel_diff_scroll_offset + MAX_VISIBLE_ITEMS && i < diff_count; i++) {
                 char name[128]; strcpy(name, difficulties[i]); *strrchr(name, '.') = '\0';
                 render_text_bitmap(renderer, name, SCREEN_WIDTH/2, start_y, (i == sel_diff_idx ? COLOR_SELECTED : COLOR_WHITE), true);
                 start_y += 40;
            }
        } else if (currentScreen == STATE_OPTIONS) {
            render_text_bitmap(renderer, "Opcoes", SCREEN_WIDTH/2, 30, COLOR_WHITE, true); char buffer[128]; int y = 120;
            sprintf(buffer, "Scroll: <%s>", options.scrollDir == SCROLL_UP ? "Upscroll" : "Downscroll"); render_text_bitmap(renderer, buffer, SCREEN_WIDTH/2, y, (sel_option_idx == 0 ? COLOR_SELECTED : COLOR_WHITE), true); y+=50;
            sprintf(buffer, "Middlescroll: <%s>", options.isMiddleScroll ? "On" : "Off"); render_text_bitmap(renderer, buffer, SCREEN_WIDTH/2, y, (sel_option_idx == 1 ? COLOR_SELECTED : COLOR_WHITE), true); y+=50;
            sprintf(buffer, "Ghost Tapping: <%s>", options.ghostTapping ? "On" : "Off"); render_text_bitmap(renderer, buffer, SCREEN_WIDTH/2, y, (sel_option_idx == 2 ? COLOR_SELECTED : COLOR_WHITE), true); y+=50;
            render_text_bitmap(renderer, "Configurar Teclas", SCREEN_WIDTH/2, y, (sel_option_idx == 3 ? COLOR_SELECTED : COLOR_WHITE), true); y+=100;
            render_text_bitmap(renderer, "INICIAR JOGO", SCREEN_WIDTH/2, y, (sel_option_idx == 4 ? COLOR_SELECTED : COLOR_WHITE), true);
        } else if (currentScreen == STATE_KEYBINDS) {
            render_text_bitmap(renderer, "Configurar Teclas", SCREEN_WIDTH/2, 20, COLOR_WHITE, true); int y = 80;
            for(int i=0; i<8; i++) { char buffer[128]; const char* prefix = (i < 4) ? "" : "Alt "; const char* key_name = SDL_GetKeyName( (i<4) ? options.keybinds_main[i] : options.keybinds_alt[i-4] ); sprintf(buffer, "%s%s: <%s>", prefix, (i%4==0)?"Left":(i%4==1)?"Down":(i%4==2)?"Up":"Right", (keybind_to_change == i) ? "..." : key_name); render_text_bitmap(renderer, buffer, SCREEN_WIDTH/2, y, (sel_option_idx == i ? COLOR_SELECTED : COLOR_WHITE), true); y+=35; }
            render_text_bitmap(renderer, "Voltar", SCREEN_WIDTH/2, y+20, (sel_option_idx == 8 ? COLOR_SELECTED : COLOR_WHITE), true);
        } else if (currentScreen == STATE_RESULTS) {
            render_text_bitmap(renderer, "Resultados", SCREEN_WIDTH/2, 30, COLOR_WHITE, true); char buffer[128];
            sprintf(buffer, "Sicks: %d", results.sicks); render_text_bitmap(renderer, buffer, 100, 100, COLOR_WHITE, false);
            sprintf(buffer, "Goods: %d", results.goods); render_text_bitmap(renderer, buffer, 100, 130, COLOR_WHITE, false);
            sprintf(buffer, "Bads: %d", results.bads); render_text_bitmap(renderer, buffer, 100, 160, COLOR_WHITE, false);
            sprintf(buffer, "Shits: %d", results.shits); render_text_bitmap(renderer, buffer, 100, 190, COLOR_WHITE, false);
            sprintf(buffer, "Misses: %d", results.misses); render_text_bitmap(renderer, buffer, 100, 220, COLOR_WHITE, false);
            sprintf(buffer, "Highest Combo: %d", results.highest_combo); render_text_bitmap(renderer, buffer, 100, 280, COLOR_WHITE, false);
            sprintf(buffer, "Score: %d", results.score); render_text_bitmap(renderer, buffer, 100, 310, COLOR_WHITE, false);
            render_text_bitmap(renderer, "Pressione A/Enter para continuar", SCREEN_WIDTH/2, 420, COLOR_WHITE, true);
        }
        SDL_RenderPresent(renderer); SDL_Delay(1000 / FPS);
    }

    // --- Limpeza Final ---
    for(int i=0; i<song_count; i++) { free(songs[i].name); free(songs[i].prefix); }
    for(int i=0; i<diff_count; i++) free(difficulties[i]);
    
    SDL_DestroyTexture(font_texture);
    if (controller) SDL_GameControllerClose(controller);
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    Mix_CloseAudio();
    SDL_Quit();
    shutdown_logging();
    return 0;
}